{"componentChunkName":"component---src-templates-post-js","path":"/blog/cloudformer/","result":{"data":{"mdx":{"frontmatter":{"title":"Reverse engineering CloudFormation templates using CloudFormer — Route 53 example","date":"2018-10-01","excerpt":"Reverse engineering CloudFormation templates using CloudFormer — Route 53 example"},"code":{"body":"function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar layoutProps = {};\n\nvar MDXContent =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inherits(MDXContent, _React$Component);\n\n  function MDXContent(props) {\n    var _this;\n\n    _classCallCheck(this, MDXContent);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(MDXContent).call(this, props));\n    _this.layout = null;\n    return _this;\n  }\n\n  _createClass(MDXContent, [{\n    key: \"render\",\n    value: function render() {\n      var _this$props = this.props,\n          components = _this$props.components,\n          props = _objectWithoutProperties(_this$props, [\"components\"]);\n\n      return React.createElement(MDXTag, {\n        name: \"wrapper\",\n        components: components\n      }, React.createElement(MDXTag, {\n        name: \"p\",\n        components: components\n      }, \"This post tries to explain how to work backwards from a functioning \", React.createElement(MDXTag, {\n        name: \"strong\",\n        components: components,\n        parentName: \"p\"\n      }, \"Route 53\"), \" configuration to a codified \", React.createElement(MDXTag, {\n        name: \"strong\",\n        components: components,\n        parentName: \"p\"\n      }, \"CloudFormation\"), \" file using Amazon Web Services\\u2019s \", React.createElement(MDXTag, {\n        name: \"strong\",\n        components: components,\n        parentName: \"p\"\n      }, \"CloudFormer\"), \" tool. Note that at the time of writing CloudFormer is still in beta phase.\"), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components\n      }, \"CloudFormer isn\\u2019t specific to Route 53 and can be used with a lot of other AWS services. I have chosen Route 53 as an example due to the relative simplicity of the configuration, at least in my example, compared to some other services and because I do not yet have a working version of a CloudFormation Route 53 template.\"), React.createElement(MDXTag, {\n        name: \"h4\",\n        components: components,\n        props: {\n          \"id\": \"prerequisites-and-assumptions\",\n          \"style\": {\n            \"position\": \"relative\"\n          }\n        }\n      }, React.createElement(MDXTag, {\n        name: \"a\",\n        components: components,\n        parentName: \"h4\",\n        props: {\n          \"href\": \"#prerequisites-and-assumptions\",\n          \"aria-label\": \"prerequisites and assumptions permalink\",\n          \"className\": \"anchor before\"\n        }\n      }, React.createElement(MDXTag, {\n        name: \"svg\",\n        components: components,\n        parentName: \"a\",\n        props: {\n          \"aria-hidden\": \"true\",\n          \"focusable\": \"false\",\n          \"height\": \"16\",\n          \"version\": \"1.1\",\n          \"viewBox\": \"0 0 16 16\",\n          \"width\": \"16\"\n        }\n      }, React.createElement(MDXTag, {\n        name: \"path\",\n        components: components,\n        parentName: \"svg\",\n        props: {\n          \"fillRule\": \"evenodd\",\n          \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n        }\n      }))), \"Prerequisites and assumptions\"), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components\n      }, \"This post is written using the example of hosting a static website (or website front end) using AWS S3, CloudFront and Certificate Manager. That does not mean to say the same method cannot be applied to other configurations, only that any service-specific gotyas won\\u2019t be included.\"), React.createElement(MDXTag, {\n        name: \"h4\",\n        components: components,\n        props: {\n          \"id\": \"getting-started-creating-the-cloudformer-stack-with-cloudformation\",\n          \"style\": {\n            \"position\": \"relative\"\n          }\n        }\n      }, React.createElement(MDXTag, {\n        name: \"a\",\n        components: components,\n        parentName: \"h4\",\n        props: {\n          \"href\": \"#getting-started-creating-the-cloudformer-stack-with-cloudformation\",\n          \"aria-label\": \"getting started creating the cloudformer stack with cloudformation permalink\",\n          \"className\": \"anchor before\"\n        }\n      }, React.createElement(MDXTag, {\n        name: \"svg\",\n        components: components,\n        parentName: \"a\",\n        props: {\n          \"aria-hidden\": \"true\",\n          \"focusable\": \"false\",\n          \"height\": \"16\",\n          \"version\": \"1.1\",\n          \"viewBox\": \"0 0 16 16\",\n          \"width\": \"16\"\n        }\n      }, React.createElement(MDXTag, {\n        name: \"path\",\n        components: components,\n        parentName: \"svg\",\n        props: {\n          \"fillRule\": \"evenodd\",\n          \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n        }\n      }))), \"Getting started: Creating the CloudFormer stack with CloudFormation\"), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components\n      }, \"CloudFormer isn\\u2019t a first-class AWS service in the sense that you can\\u2019t navigate to it via the \\u201CServices\\u201D drop-down and it won\\u2019t appear if you try to search for it in the \\u201CFind a service by\\u2026\\u201D search bar, either. If your CloudFormation looks bare (in your \", React.createElement(MDXTag, {\n        name: \"a\",\n        components: components,\n        parentName: \"p\",\n        props: {\n          \"href\": \"https://aws.amazon.com/about-aws/global-infrastructure/\"\n        }\n      }, \"region\"), \"), you will just be able to select CloudFormer. If you already have stacks in your region, select \\u201CCreate Stack\\u201D and then choose \\u201CCloudFormer\\u201D (under \\u201CTools\\u201D) from the \\u201CSelect a sample template\\u201D drop-down. Confusingly enough, in order to use CloudFormer (to ultimately create stacks of infrastructure) you must first create a stack for CloudFormer itself, hence the use of the generic stack creation wizard. (This feels to me like an unnecessary overhead that AWS could have avoided and maybe it will change if CloudFormer ever gets a full release but I couldn\\u2019t find any official information on the matter.)\"), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components\n      }, \"Give your stack a name and choose a username and password \\u2013 you will need these to log into your CloudFormer EC2 instance. This may seem like overkill for what we\\u2019re trying to achieve (and it may well be) but don\\u2019t worry, your EC2 instance only needs to be running for a few minutes while CloudFormer reverse engineers CloudFormation templates for the resources you select. According to the AWS \", React.createElement(MDXTag, {\n        name: \"a\",\n        components: components,\n        parentName: \"p\",\n        props: {\n          \"href\": \"https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/cfn-using-cloudformer.html\"\n        }\n      }, \"documentation\"), \":\"), React.createElement(MDXTag, {\n        name: \"blockquote\",\n        components: components\n      }, React.createElement(MDXTag, {\n        name: \"p\",\n        components: components,\n        parentName: \"blockquote\"\n      }, \"CloudFormer is an AWS CloudFormation stack. You run CloudFormer by launching the stack from your AWS environment. It runs on a t2.medium Amazon EC2 instance and requires no other resources.\")), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components\n      }, \"If you\\u2019re just playing around with AWS and don\\u2019t have much in your account, you\\u2019re probably fine to just use the \", React.createElement(MDXTag, {\n        name: \"a\",\n        components: components,\n        parentName: \"p\",\n        props: {\n          \"href\": \"https://docs.aws.amazon.com/vpc/latest/userguide/default-vpc.html\"\n        }\n      }, \"default\"), \" VPC but if that\\u2019s not the case, you should create a new VPC in which your CloudFormer stack will be located.\"), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components\n      }, \"Given that you are just going to be using this stack for executing CloudFormer tasks, you can leave all the fields and dropdowns in the \\u201COptions\\u201D stage blank.\"), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components\n      }, \"Tick the checkbox to say that you\\u2019re cool with the fact that CloudFormation might create some IAM resources. It\\u2019s generic for stack creation and in this case a role with the various list and read \", React.createElement(MDXTag, {\n        name: \"a\",\n        components: components,\n        parentName: \"p\",\n        props: {\n          \"href\": \"https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_understand-policy-summary-access-level-summaries.html\"\n        }\n      }, \"permissions\"), \" will be created for the CloudFormer application so that it can do its thing. This will be deleted if you choose to delete your CloudFormer stack. Select \\u201CCreate\\u201D. Once the status of your stack changes from \", React.createElement(MDXTag, {\n        name: \"code\",\n        components: components,\n        parentName: \"p\",\n        props: {\n          \"className\": \"language-text\"\n        }\n      }, \"CREATE_IN_PROGRESS\"), \" to \", React.createElement(MDXTag, {\n        name: \"code\",\n        components: components,\n        parentName: \"p\",\n        props: {\n          \"className\": \"language-text\"\n        }\n      }, \"CREATE_COMPLETE\"), \", you\\u2019re good to go.\"), React.createElement(MDXTag, {\n        name: \"h4\",\n        components: components,\n        props: {\n          \"id\": \"accessing-and-using-the-cloudformer-tool\",\n          \"style\": {\n            \"position\": \"relative\"\n          }\n        }\n      }, React.createElement(MDXTag, {\n        name: \"a\",\n        components: components,\n        parentName: \"h4\",\n        props: {\n          \"href\": \"#accessing-and-using-the-cloudformer-tool\",\n          \"aria-label\": \"accessing and using the cloudformer tool permalink\",\n          \"className\": \"anchor before\"\n        }\n      }, React.createElement(MDXTag, {\n        name: \"svg\",\n        components: components,\n        parentName: \"a\",\n        props: {\n          \"aria-hidden\": \"true\",\n          \"focusable\": \"false\",\n          \"height\": \"16\",\n          \"version\": \"1.1\",\n          \"viewBox\": \"0 0 16 16\",\n          \"width\": \"16\"\n        }\n      }, React.createElement(MDXTag, {\n        name: \"path\",\n        components: components,\n        parentName: \"svg\",\n        props: {\n          \"fillRule\": \"evenodd\",\n          \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n        }\n      }))), \"Accessing and using the CloudFormer tool\"), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components\n      }, \"Navigate to your CloudFormer stack and then its \\u201COutputs\\u201D. There should be one output. Click on its value. Enter your username and password when prompted.\"), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components\n      }, \"Well done, you\\u2019re \", React.createElement(MDXTag, {\n        name: \"em\",\n        components: components,\n        parentName: \"p\"\n      }, \"finally\"), \" ready to use CloudFormer. Choose your region and hit \\u201CCreate Template\\u201D. Entering \\u201Cdns\\u201D in the filter box will automatically select any resources that fit that description. You\\u2019ll still have to navigate through all the other services, just leave them un-ticked. Check that the information on the \\u201CSummary\\u201D page makes sense and hit \\u201CContinue\\u201D.\"), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components\n      }, \"Hopefully, you can now see your template. The NS and SOA records will not have been codified and will be created automatically when you create your new hosted zone. You can go ahead and delete your CloudFormer stack or just stop the EC2 instance on which it\\u2019s running if you want to play around a bit more.\"), React.createElement(MDXTag, {\n        name: \"h4\",\n        components: components,\n        props: {\n          \"id\": \"a-note-hosted-zone-names-and-ids\",\n          \"style\": {\n            \"position\": \"relative\"\n          }\n        }\n      }, React.createElement(MDXTag, {\n        name: \"a\",\n        components: components,\n        parentName: \"h4\",\n        props: {\n          \"href\": \"#a-note-hosted-zone-names-and-ids\",\n          \"aria-label\": \"a note hosted zone names and ids permalink\",\n          \"className\": \"anchor before\"\n        }\n      }, React.createElement(MDXTag, {\n        name: \"svg\",\n        components: components,\n        parentName: \"a\",\n        props: {\n          \"aria-hidden\": \"true\",\n          \"focusable\": \"false\",\n          \"height\": \"16\",\n          \"version\": \"1.1\",\n          \"viewBox\": \"0 0 16 16\",\n          \"width\": \"16\"\n        }\n      }, React.createElement(MDXTag, {\n        name: \"path\",\n        components: components,\n        parentName: \"svg\",\n        props: {\n          \"fillRule\": \"evenodd\",\n          \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n        }\n      }))), \"A Note: Hosted Zone Names and IDs\"), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components\n      }, \"It is possible to specify the hosted zone to attach record sets using either \", React.createElement(MDXTag, {\n        name: \"code\",\n        components: components,\n        parentName: \"p\",\n        props: {\n          \"className\": \"language-text\"\n        }\n      }, \"HostedZoneName\"), \" or \", React.createElement(MDXTag, {\n        name: \"code\",\n        components: components,\n        parentName: \"p\",\n        props: {\n          \"className\": \"language-text\"\n        }\n      }, \"HostedZoneId\"), \". It\\u2019s also possible to have more than one hosted zone with the same name. However, the Hosted Zone IDs are unique and if you try to attach a record set or record set group to a hosted zone by defining the name and more than one hosted zone of that name exists, the stack creation will fail.\"), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components\n      }, \"I have found that referencing the ID (see the template below) of the just-created hosted zone in the template to be more reliable than its name (CloudFormation just seems to complain a bit less).\"), React.createElement(MDXTag, {\n        name: \"h4\",\n        components: components,\n        props: {\n          \"id\": \"converting-to-yaml-optional\",\n          \"style\": {\n            \"position\": \"relative\"\n          }\n        }\n      }, React.createElement(MDXTag, {\n        name: \"a\",\n        components: components,\n        parentName: \"h4\",\n        props: {\n          \"href\": \"#converting-to-yaml-optional\",\n          \"aria-label\": \"converting to yaml optional permalink\",\n          \"className\": \"anchor before\"\n        }\n      }, React.createElement(MDXTag, {\n        name: \"svg\",\n        components: components,\n        parentName: \"a\",\n        props: {\n          \"aria-hidden\": \"true\",\n          \"focusable\": \"false\",\n          \"height\": \"16\",\n          \"version\": \"1.1\",\n          \"viewBox\": \"0 0 16 16\",\n          \"width\": \"16\"\n        }\n      }, React.createElement(MDXTag, {\n        name: \"path\",\n        components: components,\n        parentName: \"svg\",\n        props: {\n          \"fillRule\": \"evenodd\",\n          \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n        }\n      }))), \"Converting to YAML (optional)\"), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components\n      }, \"CloudFormer still only supports JSON output (despite AWS themselves \", React.createElement(MDXTag, {\n        name: \"a\",\n        components: components,\n        parentName: \"p\",\n        props: {\n          \"href\": \"https://aws.amazon.com/blogs/mt/the-virtues-of-yaml-cloudformation-and-using-cloudformation-designer-to-convert-json-to-yaml/\"\n        }\n      }, \"suggesting\"), \" that YAML should be the weapon of choice for CloudFormation). You will see the option to save your template to S3 but I prefer to copy and paste it into my relevant project so that it\\u2019s version-controlled. AWS provides a designer through the Console that can be used to convert JSON to YAML and there are other tools available but my preference is to use AWS Labs\\u2019s \", React.createElement(MDXTag, {\n        name: \"a\",\n        components: components,\n        parentName: \"p\",\n        props: {\n          \"href\": \"https://github.com/awslabs/aws-cfn-template-flip\"\n        }\n      }, \"aws-cfn-template-flip\"), \" command line tool.\"), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components\n      }, \"By following the instructions on GitHub and replacing the masked (potentially sensitive) values where appropriate, your template should transform from this:\"), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components\n      }, \"{% gist 38ee3601d1b327d2b6f7f6394c907e61 %}\"), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components\n      }, \"To this:\"), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components\n      }, \"{% gist 3adc4d9f209928a7b3b9d34e9ded05a0 %}\"), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components\n      }, \"Note that \", React.createElement(MDXTag, {\n        name: \"code\",\n        components: components,\n        parentName: \"p\",\n        props: {\n          \"className\": \"language-text\"\n        }\n      }, \"HostedZoneId\"), \" is the same for \", React.createElement(MDXTag, {\n        name: \"em\",\n        components: components,\n        parentName: \"p\"\n      }, \"all\"), \" CloudFront distributions, that is, \", React.createElement(MDXTag, {\n        name: \"code\",\n        components: components,\n        parentName: \"p\",\n        props: {\n          \"className\": \"language-text\"\n        }\n      }, \"Z2FDTNDATAQYW2\"), \". It also worth mentioning that I am choosing to keep all my files in the root of my project.\"), React.createElement(MDXTag, {\n        name: \"h4\",\n        components: components,\n        props: {\n          \"id\": \"deploying-your-template\",\n          \"style\": {\n            \"position\": \"relative\"\n          }\n        }\n      }, React.createElement(MDXTag, {\n        name: \"a\",\n        components: components,\n        parentName: \"h4\",\n        props: {\n          \"href\": \"#deploying-your-template\",\n          \"aria-label\": \"deploying your template permalink\",\n          \"className\": \"anchor before\"\n        }\n      }, React.createElement(MDXTag, {\n        name: \"svg\",\n        components: components,\n        parentName: \"a\",\n        props: {\n          \"aria-hidden\": \"true\",\n          \"focusable\": \"false\",\n          \"height\": \"16\",\n          \"version\": \"1.1\",\n          \"viewBox\": \"0 0 16 16\",\n          \"width\": \"16\"\n        }\n      }, React.createElement(MDXTag, {\n        name: \"path\",\n        components: components,\n        parentName: \"svg\",\n        props: {\n          \"fillRule\": \"evenodd\",\n          \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n        }\n      }))), \"Deploying your template\"), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components\n      }, \"Before deploying your template it might be worth taking a screenshot or making a note of your current configuration, in case anything goes wrong.\"), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components\n      }, \"There are two ways to proceed:\"), React.createElement(MDXTag, {\n        name: \"ul\",\n        components: components\n      }, React.createElement(MDXTag, {\n        name: \"li\",\n        components: components,\n        parentName: \"ul\"\n      }, \"Running a shell script to create the CloudFormation stack (faster)\"), React.createElement(MDXTag, {\n        name: \"li\",\n        components: components,\n        parentName: \"ul\"\n      }, \"Pushing your code to a hooked-up repo and letting CodePipeline do the stack creation (better)\")), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components\n      }, \"This post is going to follow the first option. I will have another post coming soon to explain how to create continuous delivery pipelines with CloudFormation and CodePipeline.\"), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components\n      }, \"Firstly, we\\u2019ll need to delete your existing Route 53 hosted zone. Confirm that your website is no longer reachable using a new private browser window (in case of caching).\"), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components\n      }, \"Next, you\\u2019ll want to create a \", React.createElement(MDXTag, {\n        name: \"code\",\n        components: components,\n        parentName: \"p\",\n        props: {\n          \"className\": \"language-text\"\n        }\n      }, \"parameters\"), \" file in which to extract any commonalities. This will be passed as an argument when we create the stack and has to be JSON. Note that CloudFormation will automatically add the period at the end of your top-level domain when creating the hosted zone and record sets. Mine looks like this:\"), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components\n      }, \"{% gist 5401d47b70f118ffe127e8037fad805d %}\"), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components\n      }, \"And my resultant template, after making use of some CloudFormation substitution syntax, looks like this:\"), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components\n      }, \"{% gist d4272b79c7f04e8527d6e86dbeae6923 %}\"), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components\n      }, \"Then execute the script below from the same directory as your YAML template.\"), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components\n      }, \"{% gist bf58134a77a018fa4ad6302c00b5f061 %}\"), React.createElement(MDXTag, {\n        name: \"h4\",\n        components: components,\n        props: {\n          \"id\": \"name-servers-ns-and-start-of-authority-soa-records\",\n          \"style\": {\n            \"position\": \"relative\"\n          }\n        }\n      }, React.createElement(MDXTag, {\n        name: \"a\",\n        components: components,\n        parentName: \"h4\",\n        props: {\n          \"href\": \"#name-servers-ns-and-start-of-authority-soa-records\",\n          \"aria-label\": \"name servers ns and start of authority soa records permalink\",\n          \"className\": \"anchor before\"\n        }\n      }, React.createElement(MDXTag, {\n        name: \"svg\",\n        components: components,\n        parentName: \"a\",\n        props: {\n          \"aria-hidden\": \"true\",\n          \"focusable\": \"false\",\n          \"height\": \"16\",\n          \"version\": \"1.1\",\n          \"viewBox\": \"0 0 16 16\",\n          \"width\": \"16\"\n        }\n      }, React.createElement(MDXTag, {\n        name: \"path\",\n        components: components,\n        parentName: \"svg\",\n        props: {\n          \"fillRule\": \"evenodd\",\n          \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n        }\n      }))), \"Name servers (NS) and start-of-authority (SOA) records\"), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components\n      }, \"Each time you create a new hosted zone in Route 53, Amazon will automatically create NS (one, with four values) and SOA \", React.createElement(MDXTag, {\n        name: \"a\",\n        components: components,\n        parentName: \"p\",\n        props: {\n          \"href\": \"https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/SOA-NSrecords.html\"\n        }\n      }, \"records\"), \". As far as I\\u2019m aware, there is no way to prescribe these for Route 53 \\u2014 you must use the records created for you.\"), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components\n      }, \"There is one final, manual step which involves updating the name servers of your registered domain. Note that the relationship between a registered domain and hosted zones is \", React.createElement(MDXTag, {\n        name: \"a\",\n        components: components,\n        parentName: \"p\",\n        props: {\n          \"href\": \"https://aws.amazon.com/route53/faqs/#create_multiple_hzs_for_same_domain\"\n        }\n      }, \"one-to-many\"), \". When you executed the above script and Route 53 generated a new name server record (with four entries), your domain\\u2019s name servers weren\\u2019t updated and remained as they were for the first hosted zone you (manually) created in your domain.\"), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components\n      }, \"If you navigate to Route 53 > Registered domains > \", React.createElement(MDXTag, {\n        name: \"em\",\n        components: components,\n        parentName: \"p\"\n      }, \"Your Domain\"), \" and check out the list of name servers, you will see that they no longer match the list of addresses in the \\u201CValue\\u201D field of the \\u201CNS\\u201D record in your hosted zone. All that remains to be done is to update the name servers values on the registered domain page with the values from your hosted zone record.\"), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components\n      }, React.createElement(MDXTag, {\n        name: \"a\",\n        components: components,\n        parentName: \"p\",\n        props: {\n          \"href\": \"https://serverfault.com/questions/838330/deleted-then-recreated-route-53-hosted-zones-now-website-not-working/838396#838396\"\n        }\n      }, \"This\"), \" \", React.createElement(MDXTag, {\n        name: \"em\",\n        components: components,\n        parentName: \"p\"\n      }, \"Server Fault\"), \" answer does a better job of explaining it than I do.\"), React.createElement(MDXTag, {\n        name: \"h4\",\n        components: components,\n        props: {\n          \"id\": \"has-it-worked\",\n          \"style\": {\n            \"position\": \"relative\"\n          }\n        }\n      }, React.createElement(MDXTag, {\n        name: \"a\",\n        components: components,\n        parentName: \"h4\",\n        props: {\n          \"href\": \"#has-it-worked\",\n          \"aria-label\": \"has it worked permalink\",\n          \"className\": \"anchor before\"\n        }\n      }, React.createElement(MDXTag, {\n        name: \"svg\",\n        components: components,\n        parentName: \"a\",\n        props: {\n          \"aria-hidden\": \"true\",\n          \"focusable\": \"false\",\n          \"height\": \"16\",\n          \"version\": \"1.1\",\n          \"viewBox\": \"0 0 16 16\",\n          \"width\": \"16\"\n        }\n      }, React.createElement(MDXTag, {\n        name: \"path\",\n        components: components,\n        parentName: \"svg\",\n        props: {\n          \"fillRule\": \"evenodd\",\n          \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n        }\n      }))), \"Has it worked?\"), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components\n      }, \"Validating that the stack creation has been successful is easy: just navigate to CloudFormation via the AWS Console and, like before with the CloudFormer stack, (hopefully) watch the status change from \", React.createElement(MDXTag, {\n        name: \"code\",\n        components: components,\n        parentName: \"p\",\n        props: {\n          \"className\": \"language-text\"\n        }\n      }, \"CREATE_IN_PROGRESS\"), \" to \", React.createElement(MDXTag, {\n        name: \"code\",\n        components: components,\n        parentName: \"p\",\n        props: {\n          \"className\": \"language-text\"\n        }\n      }, \"CREATE_COMPLETE\"), \".\"), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components\n      }, \"If the creation of the stack has been unsuccessful, CloudFormation will try to rollback to the previous (successful) version. Given that this is the first version of the stack and CloudFormation has nothing to which it can rollback, you will have to manually delete the failed stack before tweaking your template and retrying.\"), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components\n      }, \"To validate that the DNS setup is functioning correctly, the first thing to do is check that everything looks as before in Route 53. Frustratingly, due to DNS propagation \", React.createElement(MDXTag, {\n        name: \"a\",\n        components: components,\n        parentName: \"p\",\n        props: {\n          \"href\": \"https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/troubleshooting-new-dns-settings-not-in-effect.html\"\n        }\n      }, \"times\"), \", you won\\u2019t be able to \", React.createElement(MDXTag, {\n        name: \"em\",\n        components: components,\n        parentName: \"p\"\n      }, \"fully\"), \" validate that your new configuration is functional straight away.\"), React.createElement(MDXTag, {\n        name: \"h4\",\n        components: components,\n        props: {\n          \"id\": \"next\",\n          \"style\": {\n            \"position\": \"relative\"\n          }\n        }\n      }, React.createElement(MDXTag, {\n        name: \"a\",\n        components: components,\n        parentName: \"h4\",\n        props: {\n          \"href\": \"#next\",\n          \"aria-label\": \"next permalink\",\n          \"className\": \"anchor before\"\n        }\n      }, React.createElement(MDXTag, {\n        name: \"svg\",\n        components: components,\n        parentName: \"a\",\n        props: {\n          \"aria-hidden\": \"true\",\n          \"focusable\": \"false\",\n          \"height\": \"16\",\n          \"version\": \"1.1\",\n          \"viewBox\": \"0 0 16 16\",\n          \"width\": \"16\"\n        }\n      }, React.createElement(MDXTag, {\n        name: \"path\",\n        components: components,\n        parentName: \"svg\",\n        props: {\n          \"fillRule\": \"evenodd\",\n          \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n        }\n      }))), \"Next\"), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components\n      }, \"This is a very simple example and it\\u2019s unlikely that you\\u2019ll want to regular programmatically deploy Route 53 configurations, though, of course, it is always useful to have them codified. I just wanted to show the power of CloudFormer, especially if you\\u2019re someone (like me) who has spent a long time painfully tweaking CloudFormation templates.\"));\n    }\n  }]);\n\n  return MDXContent;\n}(React.Component);\n\nreturn MDXContent;\nMDXContent.isMDXComponent = true;"}}},"pageContext":{"slug":"/blog/cloudformer/"}}}